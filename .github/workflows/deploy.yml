name: Deploy Whisnap to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  DEPLOY_USER: ${{ secrets.VPS_USER }}
  DEPLOY_HOST: ${{ secrets.VPS_HOST }}
  COMPOSE_PROJECT_NAME: whisnap-live

jobs:
  deploy:
    name: Production Deployment
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
    - name: üì¶ Checkout Repository
      uses: actions/checkout@v4
      
    - name: üîß Configure SSH
      uses: shimataro/ssh-key-action@v2
      with:
        key: ${{ secrets.VPS_SSH_KEY }}
        known_hosts: ${{ secrets.VPS_KNOWN_HOSTS }}
        
    - name: üöÄ Sync Application Code
      run: |
        echo "üì¶ Syncing code to deployment directory..."
        rsync -avz --delete \
          --exclude='.git' \
          --exclude='node_modules' \
          --exclude='.next' \
          --exclude='dist' \
          --exclude='coverage' \
          --exclude='docs' \
          . ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }}:/root/whisnap-deploy/
        echo "‚úÖ Code sync complete"

    - name: üîê Setup Environment & SSL
      run: |
        ssh ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'EOF'
        set -e  # Exit on any error
        
        echo "üîê Creating production environment file..."
        cat > /root/whisnap-deploy/.env.prod << ENVEOF
        DATABASE_NAME=whisnap_prod
        DATABASE_USER=whisnap_prod_user
        DATABASE_PASSWORD=${{ secrets.DATABASE_PASSWORD }}
        DATABASE_PORT=5432
        ENCRYPTION_KEY=${{ secrets.ENCRYPTION_KEY }}
        JWT_SECRET=${{ secrets.JWT_SECRET }}
        NEXTAUTH_SECRET=${{ secrets.NEXTAUTH_SECRET }}
        NEXTAUTH_URL=https://whisnap.com
        GOOGLE_ID=${{ secrets.GOOGLE_ID }}
        GOOGLE_SECRET=${{ secrets.GOOGLE_SECRET }}
        STRIPE_PUBLIC_KEY=${{ secrets.STRIPE_PUBLIC_KEY }}
        STRIPE_SECRET_KEY=${{ secrets.STRIPE_SECRET_KEY }}
        STRIPE_WEBHOOK_SECRET=${{ secrets.STRIPE_WEBHOOK_SECRET }}
        RESEND_API_KEY=${{ secrets.RESEND_API_KEY }}
        EMAIL_SERVER=${{ secrets.EMAIL_SERVER }}
        OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
        ANTHROPIC_API_KEY=${{ secrets.ANTHROPIC_API_KEY }}
        GOOGLE_AI_API_KEY=${{ secrets.GOOGLE_AI_API_KEY }}
        ASSEMBLYAI_API_KEY=${{ secrets.ASSEMBLYAI_API_KEY }}
        DEEPGRAM_API_KEY=${{ secrets.DEEPGRAM_API_KEY }}
        REV_AI_API_KEY=${{ secrets.REV_AI_API_KEY }}
        SENTRY_DSN=${{ secrets.SENTRY_DSN }}
        WEB_PORT=3000
        API_PORT=4000
        WS_PORT=4001
        REDIS_PORT=6379
        ENVEOF
        
        echo "üîí Verifying SSL certificates..."
        if [ ! -f "/etc/letsencrypt/live/whisnap.com/fullchain.pem" ]; then
          echo "‚ùå SSL certificate not found!"
          exit 1
        fi
        
        echo "üìÅ Ensuring SSL directory exists..."
        mkdir -p /root/whisnap-deploy/infra/nginx/ssl/
        
        echo "üîê Copying SSL certificates..."
        cp /etc/letsencrypt/live/whisnap.com/fullchain.pem /root/whisnap-deploy/infra/nginx/ssl/
        cp /etc/letsencrypt/live/whisnap.com/privkey.pem /root/whisnap-deploy/infra/nginx/ssl/
        
        echo "‚úÖ SSL setup complete"
        ls -la /root/whisnap-deploy/infra/nginx/ssl/
        EOF

    - name: üì¶ Backup & Prepare Deployment
      run: |
        ssh ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'EOF'
        set -e
        
        echo "üíæ Creating deployment backup..."
        if [ -d "/root/whisnap-live" ]; then
          BACKUP_DIR="/root/whisnap-backup-$(date +%Y%m%d-%H%M%S)"
          cp -r /root/whisnap-live "$BACKUP_DIR"
          echo "‚úÖ Backup created: $BACKUP_DIR"
        fi
        
        echo "üßπ Stopping current services..."
        cd /root/whisnap-live 2>/dev/null || true
        docker compose -p ${{ env.COMPOSE_PROJECT_NAME }} -f infra/docker-compose.yml down --remove-orphans || true
        
        echo "üîÑ Moving new version to live..."
        rm -rf /root/whisnap-live || true
        mv /root/whisnap-deploy /root/whisnap-live
        
        echo "‚úÖ Deployment prepared"
        EOF

    - name: üèóÔ∏è Build Application Images
      run: |
        ssh ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'EOF'
        set -e
        cd /root/whisnap-live
        
        echo "üîß Loading environment variables..."
        export $(grep -v '^#' .env.prod | grep -v '^$' | xargs)
        
        echo "üèóÔ∏è Building Docker images..."
        docker compose -p ${{ env.COMPOSE_PROJECT_NAME }} -f infra/docker-compose.yml build --no-cache
        
        echo "‚úÖ Build complete"
        EOF

    - name: üóÉÔ∏è Start Database & Migrations
      run: |
        ssh ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'EOF'
        set -e
        cd /root/whisnap-live
        
        export $(grep -v '^#' .env.prod | grep -v '^$' | xargs)
        
        echo "üóÉÔ∏è Starting PostgreSQL..."
        docker compose -p ${{ env.COMPOSE_PROJECT_NAME }} -f infra/docker-compose.yml up postgres -d
        
        echo "‚è≥ Waiting for database to be ready..."
        timeout 60 bash -c 'until docker compose -p ${{ env.COMPOSE_PROJECT_NAME }} -f infra/docker-compose.yml exec postgres pg_isready -U whisnap_prod_user -d whisnap_prod; do sleep 2; done'
        
        echo "üìä Running database migrations..."
        docker compose -p ${{ env.COMPOSE_PROJECT_NAME }} -f infra/docker-compose.yml run --rm -e HOME=/tmp web npx prisma migrate deploy
        
        echo "‚úÖ Database ready"
        EOF

    - name: üöÄ Start Application Services
      run: |
        ssh ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'EOF'
        set -e
        cd /root/whisnap-live
        
        export $(grep -v '^#' .env.prod | grep -v '^$' | xargs)
        
        echo "üöÄ Starting all services..."
        docker compose -p ${{ env.COMPOSE_PROJECT_NAME }} -f infra/docker-compose.yml up -d
        
        echo "‚úÖ Services started"
        EOF

    - name: üîç Health Check & Verification
      run: |
        ssh ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'EOF'
        set -e
        cd /root/whisnap-live
        
        echo "üîç Performing health checks..."
        
        # Function to check container health
        check_container_health() {
          local service=$1
          local max_attempts=60  # 5 minutes
          local attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            local status=$(docker compose -p ${{ env.COMPOSE_PROJECT_NAME }} -f infra/docker-compose.yml ps $service --format "{{.State}}")
            
            echo "[$attempt/$max_attempts] $service status: $status"
            
            case "$status" in
              *"Up"*|*"running"*)
                echo "‚úÖ $service is healthy"
                return 0
                ;;
              *"Restarting"*|*"Exited"*)
                echo "‚ùå $service is in failed state: $status"
                docker compose -p ${{ env.COMPOSE_PROJECT_NAME }} -f infra/docker-compose.yml logs $service --tail=20
                exit 1
                ;;
              *)
                echo "‚è≥ $service is starting..."
                ;;
            esac
            
            sleep 5
            attempt=$((attempt + 1))
          done
          
          echo "‚ùå $service health check timeout"
          exit 1
        }
        
        # Check each service
        check_container_health "postgres"
        check_container_health "api"  
        check_container_health "web"
        check_container_health "nginx"
        
        # Test endpoints
        echo "üîç Testing application endpoints..."
        
        # API health check
        if curl -f --max-time 10 http://localhost:4000/v1/health >/dev/null 2>&1; then
          echo "‚úÖ API endpoint responding"
        else
          echo "‚ùå API endpoint failed"
          docker compose -p ${{ env.COMPOSE_PROJECT_NAME }} -f infra/docker-compose.yml logs api --tail=20
          exit 1
        fi
        
        # Web health check
        if curl -f --max-time 10 http://localhost:3000/api/health >/dev/null 2>&1; then
          echo "‚úÖ Web endpoint responding"  
        else
          echo "‚ùå Web endpoint failed"
          docker compose -p ${{ env.COMPOSE_PROJECT_NAME }} -f infra/docker-compose.yml logs web --tail=20
          exit 1
        fi
        
        # External access through nginx
        if curl -f --max-time 10 -H "Host: whisnap.com" http://localhost/ >/dev/null 2>&1; then
          echo "‚úÖ External HTTP access working"
        else
          echo "‚ùå External HTTP access failed"
          docker compose -p ${{ env.COMPOSE_PROJECT_NAME }} -f infra/docker-compose.yml logs nginx --tail=20
          exit 1
        fi
        
        # HTTPS check
        if curl -f --max-time 10 -k -H "Host: whisnap.com" https://localhost/ >/dev/null 2>&1; then
          echo "‚úÖ External HTTPS access working"
        else
          echo "‚ùå External HTTPS access failed"
          docker compose -p ${{ env.COMPOSE_PROJECT_NAME }} -f infra/docker-compose.yml logs nginx --tail=20
          exit 1
        fi
        
        echo "üéâ All health checks passed!"
        echo "üìä Final container status:"
        docker compose -p ${{ env.COMPOSE_PROJECT_NAME }} -f infra/docker-compose.yml ps
        EOF

    - name: üßπ Cleanup
      if: success()
      run: |
        ssh ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'EOF'
        echo "üßπ Cleaning up unused Docker resources..."
        docker image prune -f
        docker volume prune -f
        echo "‚úÖ Cleanup complete"
        EOF

    - name: üìä Deployment Status
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "üéâ Deployment completed successfully!"
          echo "üåê Application available at: https://whisnap.com"
        else
          echo "‚ùå Deployment failed!"
          echo "üîç Check the logs above for details"
          exit 1
        fi